/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-OTP.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : OTP
 #	author : miyako
 #	2024/02/21
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-OTP.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- OTP
            
			case 1 :
				OTP_Generate(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

typedef int (*hmac_fn)(const char *, const char *, char *);

void OTP_Generate(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    std::string type        = "totp";
    int period              = 30;
    int digits              = 6;
    int counter             = 0;
    std::string algorithm   = "SHA1";
    hmac_fn hmac = hmac_algo_sha1;
    std::string secret;
    std::string base32_secret;
    std::string issuer;
    std::string otp;
    
    CUTF8String stringValue;
    
    if(ob_is_defined(options, L"secret")) {
        if(ob_get_s(options, L"secret", &stringValue)) {
            if(stringValue.length()){
                secret = std::string((const char *)stringValue.c_str(), stringValue.length());
                size_t len = BASE32_LEN(secret.length());
                std::vector<unsigned char>buf(len+1);
                base32_encode((const unsigned char *)secret.c_str(), secret.length(), &buf[0]);
                base32_secret = (const char *)&buf[0];
            }
        }
    }else if(ob_is_defined(options, L"base32_secret")) {
        if(ob_get_s(options, L"base32_secret", &stringValue)) {
            base32_secret = (const char *)stringValue.c_str();
        }
    }
    
    ob_set_s(returnValue, L"base32_secret", base32_secret.c_str());
    
    if(ob_is_defined(options, L"type")) {
        if(ob_get_s(options, L"type", &stringValue)) {
            if(stringValue == (const uint8_t *)"hotp"){
                type = "hotp";
            }
        }
    }
    
    ob_set_s(returnValue, L"type", type.c_str());
    
    if(ob_is_defined(options, L"algorithm")) {
        if(ob_get_s(options, L"algorithm", &stringValue)) {
            if(stringValue == (const uint8_t *)"SHA256"){
                algorithm = "SHA256";
                hmac = hmac_algo_sha256;
            }else if (stringValue == (const uint8_t *)"SHA512"){
                algorithm = "SHA512";
                hmac = hmac_algo_sha512;
            }
        }
    }
    
    ob_set_s(returnValue, L"algorithm", algorithm.c_str());

    ob_set_s(returnValue, L"algorithm", algorithm.c_str());
    
    int intValue;
    
    if(ob_is_defined(options, L"digits")) {
        intValue = ob_get_n(options, L"digits");
        if(intValue > 0){
            digits = intValue;
        }
    }
    
    ob_set_n(returnValue, L"digits", digits);
    
    std::vector<char>buf(digits+1);
    
    if(type == "totp"){
        if(ob_is_defined(options, L"period")) {
            intValue = ob_get_n(options, L"period");
            if(intValue > 0){
                period = intValue;
            }
        }
        
        ob_set_n(returnValue, L"period", period);
        

        
    }
    
    if(type == "hotp"){
        if(ob_is_defined(options, L"counter")) {
            intValue = ob_get_n(options, L"counter");
            if(intValue > 0){
                counter = intValue;
            }
        }
        
        ob_set_n(returnValue, L"counter", counter);
        

    }

    PA_ReturnObject(params, returnValue);
}

static uint64_t get_current_time() {
    
    uint64_t milliseconds = 0;
    
#if defined(_WIN32)
    FILETIME fileTime;
    GetSystemTimeAsFileTime(&fileTime);
    
    ULARGE_INTEGER largeInteger;
    largeInteger.LowPart = fileTime.dwLowDateTime;
    largeInteger.HighPart = fileTime.dwHighDateTime;
    
    milliseconds = (largeInteger.QuadPart - 116444736000000000ULL) / 10000;
#else
    struct timeval sys_time;
    gettimeofday(&sys_time, NULL);
    
    milliseconds = sys_time.tv_sec * 1000 + sys_time.tv_usec / 1000;
#endif
    
    return milliseconds;
}

static int hmac_algo_sha1(const char* byte_secret, const char* byte_string, char* out) {
    
    // Output len
    unsigned int len = SHA1_BYTES;
    
    unsigned char* result = HMAC(
        EVP_sha1(),                            // algorithm
        (unsigned char*)byte_secret, 10,    // key
        (unsigned char*)byte_string, 8,        // data
        (unsigned char*)out,                // output
        &len                                // output length
    );
    
    // Return the HMAC success
    return result == 0 ? 0 : len;
}

static int hmac_algo_sha256(const char* byte_secret, const char* byte_string, char* out) {
    
    // Output len
    unsigned int len = SHA256_BYTES;
    
    unsigned char* result = HMAC(
        EVP_sha256(),                        // algorithm
        (unsigned char*)byte_secret, 10,    // key
        (unsigned char*)byte_string, 8,        // data
        (unsigned char*)out,                // output
        &len                                // output length
    );
    
    // Return the HMAC success
    return result == 0 ? 0 : len;
}

static int hmac_algo_sha512(const char* byte_secret, const char* byte_string, char* out) {
    
    // Output len
    unsigned int len = SHA512_BYTES;
    
    unsigned char* result = HMAC(
        EVP_sha512(),                        // algorithm
        (unsigned char*)byte_secret, 10,    // key
        (unsigned char*)byte_string, 8,        // data
        (unsigned char*)out,                // output
        &len                                // output length
    );
    
    // Return the HMAC success
    return result == 0 ? 0 : len;
}
