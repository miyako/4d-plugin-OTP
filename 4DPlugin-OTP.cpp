/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-OTP.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : OTP
 #	author : miyako
 #	2024/02/21
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-OTP.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- OTP
            
			case 1 :
				OTP_Generate(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void OTP_Generate(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    std::string type        = "totp";
    int period              = 30;
    int digits              = 6;
    int counter             = 0;
    std::string algorithm   = "SHA1";
    const EVP_MD *evp_md = EVP_sha1();
    
    std::string secret;
    std::string base32_secret;
    std::string issuer;
    std::string otp;
    
    CUTF8String stringValue;
    
    if(ob_is_defined(options, L"secret")) {
        if(ob_get_s(options, L"secret", &stringValue)) {
            if(stringValue.length()){
                secret = std::string((const char *)stringValue.c_str(), stringValue.length());
                size_t len = BASE32_LEN(secret.length());
                std::vector<unsigned char>buf(len+1);
                base32_encode((const unsigned char *)secret.c_str(), secret.length(), &buf[0]);
                base32_secret = (const char *)&buf[0];
            }
        }
    }else if(ob_is_defined(options, L"base32_secret")) {
        if(ob_get_s(options, L"base32_secret", &stringValue)) {
            base32_secret = (const char *)stringValue.c_str();
        }
    }
    
    ob_set_s(returnValue, L"base32_secret", base32_secret.c_str());
    
    if(ob_is_defined(options, L"type")) {
        if(ob_get_s(options, L"type", &stringValue)) {
            if(stringValue == (const uint8_t *)"hotp"){
                type = "hotp";
            }
        }
    }
    
    ob_set_s(returnValue, L"type", type.c_str());
    
    if(ob_is_defined(options, L"algorithm")) {
        if(ob_get_s(options, L"algorithm", &stringValue)) {
            if(stringValue == (const uint8_t *)"SHA256"){
                algorithm = "SHA256";
                evp_md = EVP_sha256();
            }else if (stringValue == (const uint8_t *)"SHA512"){
                algorithm = "SHA512";
                evp_md = EVP_sha512();
            }
        }
    }
    
    ob_set_s(returnValue, L"algorithm", algorithm.c_str());

    ob_set_s(returnValue, L"algorithm", algorithm.c_str());
    
    int intValue;
    
    if(ob_is_defined(options, L"digits")) {
        intValue = ob_get_n(options, L"digits");
        if(intValue > 0){
            digits = intValue;
        }
    }
    
    ob_set_n(returnValue, L"digits", digits);
    
    std::vector<char>buf(digits+1);
    
    if(type == "totp"){
        
        if(ob_is_defined(options, L"period")) {
            intValue = ob_get_n(options, L"period");
            if(intValue > 0){
                period = intValue;
            }
        }
        
        ob_set_n(returnValue, L"period", period);
        

        
        
    }
    
    if(type == "hotp"){
        
        if(ob_is_defined(options, L"counter")) {
            intValue = ob_get_n(options, L"counter");
            if(intValue > 0){
                counter = intValue;
            }
        }
        
        ob_set_n(returnValue, L"counter", counter);
        
        const int max10 = sizeof(powers10) / sizeof(*powers10);
        const int max16 = 8;
        
        u_char tosign[8];
        
        for (int i = sizeof(tosign) - 1; i >= 0; i--) {
                tosign[i] = counter & 0xff;
                counter >>= 8;
            }

        u_int hash_len;
        u_char hash[EVP_MAX_MD_SIZE];
        
        /* Compute HMAC */
        HMAC(evp_md,
             base32_secret.c_str(),
             (int)base32_secret.length(),
             tosign,
             sizeof(tosign), hash, &hash_len);
        
        /* Extract selected bytes to get 32 bit integer value */
        int offset = hash[hash_len - 1] & 0x0f;
        int value = ((hash[offset] & 0x7f) << 24) | ((hash[offset + 1] & 0xff) << 16)
        | ((hash[offset + 2] & 0xff) << 8) | (hash[offset + 3] & 0xff);
        
        snprintf(&buf[0], buf.size(), "%0*d", digits < max10 ? digits : max10,
                 digits < max10 ? value % powers10[digits - 1] : value);
        
        otp = (const char *)&buf[0];
        ob_set_s(returnValue, L"otp", otp.c_str());
        
    }

    PA_ReturnObject(params, returnValue);
}

static uint64_t get_current_time() {
    
    uint64_t milliseconds = 0;
    
#if defined(_WIN32)
    FILETIME fileTime;
    GetSystemTimeAsFileTime(&fileTime);
    
    ULARGE_INTEGER largeInteger;
    largeInteger.LowPart = fileTime.dwLowDateTime;
    largeInteger.HighPart = fileTime.dwHighDateTime;
    
    milliseconds = (largeInteger.QuadPart - 116444736000000000ULL) / 10000;
#else
    struct timeval sys_time;
    gettimeofday(&sys_time, NULL);
    
    milliseconds = sys_time.tv_sec * 1000 + sys_time.tv_usec / 1000;
#endif
    
    return milliseconds;
}
